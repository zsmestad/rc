case `uname` in
  Linux)
    platform='linux';;
  Darwin)
    platform='unix';;
  *)
    platform='unknown';;
esac

# Prompt with git-prompt
# https://github.com/olivierverdier/zsh-git-prompt
autoload -U colors && colors
local zsh_git_path=~/.zsh/zsh-git-prompt
if [ -f "${zsh_git_path}/zshrc.sh" ]; then
  # Compile with github link instructions
  [ -x "${zsh_git_path}/src/.bin/gitstatus" ] && export GIT_PROMPT_EXECUTABLE="haskell"
  # Create directory to enable caching
  [ -d ~/.cache/zsh_git_prompt ] && export ZSH_THEME_GIT_PROMPT_CACHE=~/.cache/zsh_git_prompt
  source "${zsh_git_path}/zshrc.sh"
  PROMPT='%m %F{blue}%~%f$(git_super_status) %# '
else
  PROMPT='%m %F{blue}%~ %# %f'
fi

###################
# Shell Variables #

PATH=~/bin:/usr/local/bin:/usr/local/sbin:$PATH

# Localization
LANG='en_US.UTF-8'
LC_ALL='en_US.UTF-8'
export PYTHONIOENCODING=utf-8

# History
HISTFILE=~/.zsh_history
SAVEHIST=1000
setopt HIST_IGNORE_DUPS

# Env Vars
export PAGER="/usr/bin/less -Rs"
export EDITOR="/usr/bin/vim"
export VISUAL="$EDITOR"
export LESSEDIT="$EDITOR"
export LESSCHARSET='utf-8'
export LESS='--ignore-case -R'

############
# Bindings #

# Vi keybindings
bindkey -v
bindkey '^R' history-incremental-search-backward

#########
# Alias #
alias vi='nvim'
alias vim='nvim'

case $platform in
  'unix')
    alias ls='ls -G';;
  *)
    alias ls='ls --color=auto --time-style=long-iso';;
esac

alias  l='ls -lF'
alias la='l -A'
alias lh='l -h'

alias mp='mkdir -p'

alias   ..='cd ..'
alias  ...='cd ../..'
alias ....='cd ../../..'

alias cl='clear'


alias pl='puppet-lint --log-format "%{filename}:%{line} %{KIND} - %{message}" --no-autoloader_layout-check'
alias pp='puppet parser validate'

alias add_cwd_to_path='export PATH=`pwd`:$PATH'

##############
# Completion #
autoload -U compinit && compinit
# Case insensitive completion
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=*'
zstyle ':completion:*' completer _complete
zstyle ':completion:*' group-name ''
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' use-compctl false

if [ -f ~/.ssh/known_hosts ]; then
  local knownhosts
  knownhosts=( ${${${${(f)"$(<$HOME/.ssh/known_hosts)"}:#[0-9]*}%%\ *}%%,*} )
  zstyle ':completion:*:(ssh|scp|sftp):*' hosts $knownhosts
fi

local hfunc=~/.zsh/func
[ -d $hfunc ] && fpath+=$hfunc

local ufunc=/usr/local/share/zsh/site-functions
[ -d $ufunc ] && fpath+=$ufunc

# Attach unattached tmux session or create a new one
function tt () {
  n=$(tmux list-sessions 2> /dev/null | grep -Ev '\(attached\)$' | wc -l | tr -d '[:blank:]')
  if [ $n -gt 0 ]; then
    tmux attach $@
  else
    tmux $@
  fi
}

# I never use this, but it's just too cool to remove
extract () {
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2) tar xjf $1 ;;
         *.tbz2) tar xjf $1 ;;
          *.bz2) bunzip2 $1 ;;
       *.tar.gz) tar xzf $1 ;;
          *.tgz) tar xzf $1 ;;
           *.gz) gunzip $1 ;;
          *.tar) tar xf $1 ;;
          *.rar) unrar e $1 ;;
          *.zip) unzip $1 ;;
            *.Z) uncompress $1 ;;
           *.7z) 7z x $1 ;;
              *) echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
       echo "'$1' is not a valid file"
  fi
}

# Anonymous function - only exported variables end up in the shell environment
function () {
  # Autojump
  local aj=/usr/share/autojump/autojump.sh
  [ -f "$aj" ] && . $aj

  local nix=~/.nix-profile/etc/profile.d/nix.sh
  [ -f "$nix" ] && . "$nix"

  local zsh_local=~/.zshrc.local
  [ -f $zsh_local ] && source $zsh_local

  # Haskell Stack
  [ -d ~/.local/bin ] && export PATH=~/.local/bin:$PATH

  # Rustup - rustup.rs
  local rustup_bin=~/.cargo/bin
  [ -d "$rustup_bin" ] && export PATH="${rustup_bin}:$PATH"

  [ -x ~/.cargo/bin/sccache ] && export RUSTC_WRAPPER=sccache

  # Racer
  # https://github.com/racer-rust/racer
  if [ -x rustc ]; then
    local rust_src=$(rustc --print sysroot)/lib/rustlib/src/rust/src
    [ -d "$rust_src" ] && export RUST_SRC_PATH="$rust_src"
  fi

  # rbenv
  local rbenv_path=~/.rbenv
  [ -d "$rbenv_path" ] && export PATH="$rbenv_path/bin:$PATH"
  [ -x "$(which rbenv 2> /dev/null)" ] && eval "$(rbenv init -)"

  # pyenv
  local pyenv_path=~/.pyenv
  [ -d $pyenv_path ] && export PYENV_ROOT="$pyenv_path" && export PATH="$PYENV_ROOT/bin:$PATH"
  [ -x "$(which pyenv 2> /dev/null)" ] && eval "$(pyenv init -)"
}

# Remove dupes
typeset -U PATH
typeset -U fpath

compinit

